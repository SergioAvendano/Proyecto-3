# -*- coding: utf-8 -*-
"""Bic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ad11hSHkkJ0gHjxN3CF2VUsPx3VT9k4w
"""

pip install pgmpy networkx matplotlib

import pandas as pd
from pgmpy.estimators import PC
from pgmpy.models import BayesianModel
import networkx as nx
import matplotlib.pyplot as plt

# Leer datos
df = pd.read_excel("/content/drive/MyDrive/Colab Notebooks/DatosP3Final.xlsx")

# Limpiar datos
#df = df.dropna()

print(df.head())
print(df.describe())
print(df.columns)

from pgmpy.estimators import HillClimbSearch
from pgmpy.models import BayesianNetwork
from pgmpy.estimators import BicScore
scoring_method = BicScore(data=df)
esth = HillClimbSearch(data=df)
estimated_modelB = esth.estimate(
    scoring_method=scoring_method, max_indegree=4, max_iter=int(1e4)
)
print(estimated_modelB)
print(estimated_modelB.nodes())
print(estimated_modelB.edges())

print(scoring_method.score(estimated_modelB))

estimated_modelB = BayesianNetwork(estimated_modelB)

nx.draw_shell(estimated_modelB, with_labels=True)

from pgmpy.models import BayesianNetwork
from pgmpy.estimators import MaximumLikelihoodEstimator

estimated_modelB.fit(data=df, estimator = MaximumLikelihoodEstimator)
for i in estimated_modelB.nodes():
    print(estimated_modelB.get_cpds(i))

from pgmpy.inference import VariableElimination
from sklearn.metrics import accuracy_score, confusion_matrix

import pandas as pd
from pgmpy.estimators import HillClimbSearch, K2Score
from pgmpy.models import BayesianNetwork
from pgmpy.inference import VariableElimination
from sklearn.metrics import accuracy_score

inference = VariableElimination(estimated_modelB)
estimated_modelB = BayesianNetwork(estimated_modelB)

# Definir las variables que estás usando en tu modelo
variables = ['periodo', 'cole_depto_ubicacion', 'fami_tieneinternet', 'cole_jornada', 'cole_bilingue', 'fami_estratovivienda', 'punt_global']


# Definir las variables observadas y no observadas
observed_variables = ['periodo', 'cole_depto_ubicacion', 'fami_tieneinternet', 'cole_jornada', 'cole_bilingue', 'fami_estratovivienda']
target_variable = 'punt_global'


# Convertir las columnas a un diccionario
evidence_dict = df[observed_variables].to_dict(orient='records')[0]

# Convertir a BayesianNetwork
bayesian_model = BayesianNetwork(estimated_modelB)

predicted_values = inference.map_query(variables=[target_variable], evidence=df[observed_variables].iloc[0].to_dict())

# Obtener las etiquetas reales
true_values = df[target_variable]

# Convertir a listas
true_values_list = list(true_values)
predicted_values_list = [predicted_values[target_variable].item()]  # Convertir el valor predicho a un tipo de datos nativo

# Calcular la precisión
accuracy = accuracy_score(true_values_list, [predicted_values_list[0] for _ in range(len(true_values_list))])
print(f'Accuracy: {accuracy:.4f}')

# Obtener las predicciones de Target
predicted_target = []
for idx, row in df.iterrows():
    evidence = {
        "periodo": row["periodo"],
        "fami_tieneinternet": row["fami_tieneinternet"],
        "cole_jornada": row["cole_jornada"],
        "cole_bilingue": row["cole_bilingue"],
        "fami_estratovivienda": row["fami_estratovivienda"]
    }
    target_probabilities = inference.query(variables=["punt_global"], evidence=evidence)
    predicted_target.append(target_probabilities.values.argmax())

# Calcular la precisión
actual_target = df["punt_global"].tolist()
accuracy = accuracy_score(actual_target, predicted_target)
print(f"Precisión (Accuracy): {accuracy:.2f}")

from sklearn.model_selection import train_test_split
from pgmpy.models import BayesianNetwork
train,test = train_test_split(df, test_size=0.2,random_state= 42)

from pgmpy.estimators import HillClimbSearch
from pgmpy.models import BayesianNetwork
from pgmpy.estimators import BicScore
scoring_method = BicScore(data=train)
esth = HillClimbSearch(data=train)
estimated_modelBT = esth.estimate(
    scoring_method=scoring_method, max_indegree=4, max_iter=int(1e4)
)
print(estimated_modelBT)
print(estimated_modelBT.nodes())
print(estimated_modelBT.edges())

print(scoring_method.score(estimated_modelBT))

estimated_modelBT = BayesianNetwork(estimated_modelBT)

nx.draw_shell(estimated_modelBT, with_labels=True)

from pgmpy.models import BayesianNetwork
from pgmpy.estimators import MaximumLikelihoodEstimator

estimated_modelBT.fit(data=train, estimator = MaximumLikelihoodEstimator)
for i in estimated_modelBT.nodes():
    print(estimated_modelBT.get_cpds(i))

inferenceT = VariableElimination(estimated_modelBT)
estimated_modelBT = BayesianNetwork(estimated_modelBT)

# Definir las variables que estás usando en tu modelo
variables = ['periodo', 'cole_depto_ubicacion', 'fami_tieneinternet', 'cole_jornada', 'cole_bilingue', 'fami_estratovivienda', 'punt_global']


# Definir las variables observadas y no observadas
observed_variables = ['periodo', 'cole_depto_ubicacion', 'fami_tieneinternet', 'cole_jornada', 'cole_bilingue', 'fami_estratovivienda']
target_variable = 'punt_global'


# Convertir las columnas a un diccionario
evidence_dict = train[observed_variables].to_dict(orient='records')[0]

# Convertir a BayesianNetwork
bayesian_model = BayesianNetwork(estimated_modelBT)

predicted_values = inferenceT.map_query(variables=[target_variable], evidence=train[observed_variables].iloc[0].to_dict())

# Obtener las etiquetas reales
true_values = train[target_variable]

# Convertir a listas
true_values_list = list(true_values)
predicted_values_list = [predicted_values[target_variable].item()]  # Convertir el valor predicho a un tipo de datos nativo

# Calcular la precisión
accuracy = accuracy_score(true_values_list, [predicted_values_list[0] for _ in range(len(true_values_list))])
print(f'Accuracy: {accuracy:.4f}')

from numpy.matrixlib.defmatrix import mat
matriz = confusion_matrix(train["punt_global"],predicted_target)

matriz